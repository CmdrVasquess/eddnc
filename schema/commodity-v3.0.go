// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

type CommodityV30Json struct {
	// SchemaRef corresponds to the JSON schema field "$schemaRef".
	SchemaRef string `json:"$schemaRef"`

	// Header corresponds to the JSON schema field "header".
	Header CommodityV30JsonHeader `json:"header"`

	// Message corresponds to the JSON schema field "message".
	Message CommodityV30JsonMessage `json:"message"`
}

type CommodityV30JsonHeader struct {
	// Timestamp upon receipt at the gateway. If present, this property will be
	// overwritten by the gateway; submitters are not intended to populate this
	// property.
	GatewayTimestamp *string `json:"gatewayTimestamp,omitempty"`

	// SoftwareName corresponds to the JSON schema field "softwareName".
	SoftwareName string `json:"softwareName"`

	// SoftwareVersion corresponds to the JSON schema field "softwareVersion".
	SoftwareVersion string `json:"softwareVersion"`

	// UploaderID corresponds to the JSON schema field "uploaderID".
	UploaderID string `json:"uploaderID"`
}

type CommodityV30JsonMessage struct {
	// Commodities returned by the Companion API, with illegal commodities omitted
	Commodities []CommodityV30JsonMessageCommoditiesElem `json:"commodities"`

	// Economies corresponds to the JSON schema field "economies".
	Economies []CommodityV30JsonMessageEconomiesElem `json:"economies,omitempty"`

	// Whether the sending Cmdr has a Horizons pass.
	Horizons *bool `json:"horizons,omitempty"`

	// MarketId corresponds to the JSON schema field "marketId".
	MarketId int `json:"marketId"`

	// Prohibited corresponds to the JSON schema field "prohibited".
	Prohibited []string `json:"prohibited,omitempty"`

	// StationName corresponds to the JSON schema field "stationName".
	StationName string `json:"stationName"`

	// SystemName corresponds to the JSON schema field "systemName".
	SystemName string `json:"systemName"`

	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp string `json:"timestamp"`
}

type CommodityV30JsonMessageCommoditiesElem struct {
	// Price to buy from the market
	BuyPrice int `json:"buyPrice"`

	// Demand corresponds to the JSON schema field "demand".
	Demand int `json:"demand"`

	// DemandBracket corresponds to the JSON schema field "demandBracket".
	DemandBracket CommodityV30JsonMessageCommoditiesElemDemandBracket `json:"demandBracket"`

	// MeanPrice corresponds to the JSON schema field "meanPrice".
	MeanPrice int `json:"meanPrice"`

	// Symbolic name as returned by the Companion API
	Name string `json:"name"`

	// Price to sell to the market
	SellPrice int `json:"sellPrice"`

	// StatusFlags corresponds to the JSON schema field "statusFlags".
	StatusFlags []string `json:"statusFlags,omitempty"`

	// Stock corresponds to the JSON schema field "stock".
	Stock int `json:"stock"`

	// StockBracket corresponds to the JSON schema field "stockBracket".
	StockBracket CommodityV30JsonMessageCommoditiesElemStockBracket `json:"stockBracket"`
}

type CommodityV30JsonMessageCommoditiesElemDemandBracket interface{}

type CommodityV30JsonMessageCommoditiesElemStockBracket interface{}

type CommodityV30JsonMessageEconomiesElem struct {
	// Economy type as returned by the Companion API
	Name string `json:"name"`

	// Proportion corresponds to the JSON schema field "proportion".
	Proportion float64 `json:"proportion"`
}

type LevelType struct {
	Value interface{}
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommodityV30JsonHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["softwareName"]; !ok || v == nil {
		return fmt.Errorf("field softwareName: required")
	}
	if v, ok := raw["softwareVersion"]; !ok || v == nil {
		return fmt.Errorf("field softwareVersion: required")
	}
	if v, ok := raw["uploaderID"]; !ok || v == nil {
		return fmt.Errorf("field uploaderID: required")
	}
	type Plain CommodityV30JsonHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommodityV30JsonHeader(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommodityV30JsonMessageCommoditiesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buyPrice"]; !ok || v == nil {
		return fmt.Errorf("field buyPrice: required")
	}
	if v, ok := raw["demand"]; !ok || v == nil {
		return fmt.Errorf("field demand: required")
	}
	if v, ok := raw["demandBracket"]; !ok || v == nil {
		return fmt.Errorf("field demandBracket: required")
	}
	if v, ok := raw["meanPrice"]; !ok || v == nil {
		return fmt.Errorf("field meanPrice: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["sellPrice"]; !ok || v == nil {
		return fmt.Errorf("field sellPrice: required")
	}
	if v, ok := raw["stock"]; !ok || v == nil {
		return fmt.Errorf("field stock: required")
	}
	if v, ok := raw["stockBracket"]; !ok || v == nil {
		return fmt.Errorf("field stockBracket: required")
	}
	type Plain CommodityV30JsonMessageCommoditiesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommodityV30JsonMessageCommoditiesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LevelType) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LevelType {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LevelType, v.Value)
	}
	*j = LevelType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommodityV30JsonMessageEconomiesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["proportion"]; !ok || v == nil {
		return fmt.Errorf("field proportion: required")
	}
	type Plain CommodityV30JsonMessageEconomiesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommodityV30JsonMessageEconomiesElem(plain)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *LevelType) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommodityV30JsonMessage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commodities"]; !ok || v == nil {
		return fmt.Errorf("field commodities: required")
	}
	if v, ok := raw["marketId"]; !ok || v == nil {
		return fmt.Errorf("field marketId: required")
	}
	if v, ok := raw["stationName"]; !ok || v == nil {
		return fmt.Errorf("field stationName: required")
	}
	if v, ok := raw["systemName"]; !ok || v == nil {
		return fmt.Errorf("field systemName: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp: required")
	}
	type Plain CommodityV30JsonMessage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommodityV30JsonMessage(plain)
	return nil
}

var enumValues_LevelType = []interface{}{
	0,
	1,
	2,
	3,
	"",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommodityV30Json) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["$schemaRef"]; !ok || v == nil {
		return fmt.Errorf("field $schemaRef: required")
	}
	if v, ok := raw["header"]; !ok || v == nil {
		return fmt.Errorf("field header: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message: required")
	}
	type Plain CommodityV30Json
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommodityV30Json(plain)
	return nil
}
