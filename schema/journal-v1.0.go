// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "encoding/json"
import "reflect"

type Disallowed interface{}

type JournalV10Json struct {
	// SchemaRef corresponds to the JSON schema field "$schemaRef".
	SchemaRef string `json:"$schemaRef"`

	// Header corresponds to the JSON schema field "header".
	Header JournalV10JsonHeader `json:"header"`

	// Contains all properties from the listed events in the client's journal minus
	// Localised strings and the properties marked below as 'disallowed'
	Message JournalV10JsonMessage `json:"message"`
}

type JournalV10JsonHeader struct {
	// Timestamp upon receipt at the gateway. If present, this property will be
	// overwritten by the gateway; submitters are not intended to populate this
	// property.
	GatewayTimestamp *string `json:"gatewayTimestamp,omitempty"`

	// SoftwareName corresponds to the JSON schema field "softwareName".
	SoftwareName string `json:"softwareName"`

	// SoftwareVersion corresponds to the JSON schema field "softwareVersion".
	SoftwareVersion string `json:"softwareVersion"`

	// UploaderID corresponds to the JSON schema field "uploaderID".
	UploaderID string `json:"uploaderID"`
}

// Contains all properties from the listed events in the client's journal minus
// Localised strings and the properties marked below as 'disallowed'
type JournalV10JsonMessage struct {
	// ActiveFine corresponds to the JSON schema field "ActiveFine".
	ActiveFine JournalV10JsonMessageActiveFine `json:"ActiveFine,omitempty"`

	// BoostUsed corresponds to the JSON schema field "BoostUsed".
	BoostUsed JournalV10JsonMessageBoostUsed `json:"BoostUsed,omitempty"`

	// CockpitBreach corresponds to the JSON schema field "CockpitBreach".
	CockpitBreach JournalV10JsonMessageCockpitBreach `json:"CockpitBreach,omitempty"`

	// Present in Location, FSDJump and CarrierJump messages
	Factions []JournalV10JsonMessageFactionsElem `json:"Factions,omitempty"`

	// FuelLevel corresponds to the JSON schema field "FuelLevel".
	FuelLevel JournalV10JsonMessageFuelLevel `json:"FuelLevel,omitempty"`

	// FuelUsed corresponds to the JSON schema field "FuelUsed".
	FuelUsed JournalV10JsonMessageFuelUsed `json:"FuelUsed,omitempty"`

	// JumpDist corresponds to the JSON schema field "JumpDist".
	JumpDist JournalV10JsonMessageJumpDist `json:"JumpDist,omitempty"`

	// Latitude corresponds to the JSON schema field "Latitude".
	Latitude JournalV10JsonMessageLatitude `json:"Latitude,omitempty"`

	// Longitude corresponds to the JSON schema field "Longitude".
	Longitude JournalV10JsonMessageLongitude `json:"Longitude,omitempty"`

	// Must be added by the sender if not present in the journal event
	StarPos []float64 `json:"StarPos"`

	// Must be added by the sender if not present in the journal event
	StarSystem string `json:"StarSystem"`

	// Should be added by the sender if not present in the journal event
	SystemAddress int `json:"SystemAddress"`

	// Wanted corresponds to the JSON schema field "Wanted".
	Wanted JournalV10JsonMessageWanted `json:"Wanted,omitempty"`

	// Event corresponds to the JSON schema field "event".
	Event JournalV10JsonMessageEvent `json:"event"`

	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp string `json:"timestamp"`
}

type JournalV10JsonMessageActiveFine interface{}

type JournalV10JsonMessageBoostUsed interface{}

type JournalV10JsonMessageCockpitBreach interface{}

type JournalV10JsonMessageEvent string

const JournalV10JsonMessageEventCarrierJump JournalV10JsonMessageEvent = "CarrierJump"
const JournalV10JsonMessageEventDocked JournalV10JsonMessageEvent = "Docked"
const JournalV10JsonMessageEventFSDJump JournalV10JsonMessageEvent = "FSDJump"
const JournalV10JsonMessageEventLocation JournalV10JsonMessageEvent = "Location"
const JournalV10JsonMessageEventSAASignalsFound JournalV10JsonMessageEvent = "SAASignalsFound"
const JournalV10JsonMessageEventScan JournalV10JsonMessageEvent = "Scan"

type JournalV10JsonMessageFactionsElem struct {
	// HappiestSystem corresponds to the JSON schema field "HappiestSystem".
	HappiestSystem JournalV10JsonMessageFactionsElemHappiestSystem `json:"HappiestSystem,omitempty"`

	// HomeSystem corresponds to the JSON schema field "HomeSystem".
	HomeSystem JournalV10JsonMessageFactionsElemHomeSystem `json:"HomeSystem,omitempty"`

	// MyReputation corresponds to the JSON schema field "MyReputation".
	MyReputation JournalV10JsonMessageFactionsElemMyReputation `json:"MyReputation,omitempty"`

	// SquadronFaction corresponds to the JSON schema field "SquadronFaction".
	SquadronFaction JournalV10JsonMessageFactionsElemSquadronFaction `json:"SquadronFaction,omitempty"`
}

type JournalV10JsonMessageFactionsElemHappiestSystem interface{}

type JournalV10JsonMessageFactionsElemHomeSystem interface{}

type JournalV10JsonMessageFactionsElemMyReputation interface{}

type JournalV10JsonMessageFactionsElemSquadronFaction interface{}

type JournalV10JsonMessageFuelLevel interface{}

type JournalV10JsonMessageFuelUsed interface{}

type JournalV10JsonMessageJumpDist interface{}

type JournalV10JsonMessageLatitude interface{}

type JournalV10JsonMessageLongitude interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JournalV10JsonMessageEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_JournalV10JsonMessageEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_JournalV10JsonMessageEvent, v)
	}
	*j = JournalV10JsonMessageEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JournalV10JsonMessage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["StarPos"]; !ok || v == nil {
		return fmt.Errorf("field StarPos: required")
	}
	if v, ok := raw["StarSystem"]; !ok || v == nil {
		return fmt.Errorf("field StarSystem: required")
	}
	if v, ok := raw["SystemAddress"]; !ok || v == nil {
		return fmt.Errorf("field SystemAddress: required")
	}
	if v, ok := raw["event"]; !ok || v == nil {
		return fmt.Errorf("field event: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp: required")
	}
	type Plain JournalV10JsonMessage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JournalV10JsonMessage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JournalV10JsonHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["softwareName"]; !ok || v == nil {
		return fmt.Errorf("field softwareName: required")
	}
	if v, ok := raw["softwareVersion"]; !ok || v == nil {
		return fmt.Errorf("field softwareVersion: required")
	}
	if v, ok := raw["uploaderID"]; !ok || v == nil {
		return fmt.Errorf("field uploaderID: required")
	}
	type Plain JournalV10JsonHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JournalV10JsonHeader(plain)
	return nil
}

type JournalV10JsonMessageWanted interface{}

var enumValues_JournalV10JsonMessageEvent = []interface{}{
	"Docked",
	"FSDJump",
	"Scan",
	"Location",
	"SAASignalsFound",
	"CarrierJump",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JournalV10Json) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["$schemaRef"]; !ok || v == nil {
		return fmt.Errorf("field $schemaRef: required")
	}
	if v, ok := raw["header"]; !ok || v == nil {
		return fmt.Errorf("field header: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message: required")
	}
	type Plain JournalV10Json
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JournalV10Json(plain)
	return nil
}
